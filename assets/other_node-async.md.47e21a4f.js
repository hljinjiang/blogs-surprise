import{_ as l,c as i,o as e,O as o}from"./chunks/framework.d7e37bdc.js";const a="/assets/async_io.f371b038.png",t="/assets/await_io.e20831cf.png",r="/assets/more_thread.39e0a7cc.png",n="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAckAAACACAMAAABXwWJTAAAApVBMVEUtLS0gICLR09h8fYAvLy8xMjKBgoXLzdI2NjbBw8dub3HO0NRBQUE0NDR5enw+Pj5dXV68vsI5Ojqtr7NRUVKIioyFholISElERUXGyM2XmJtaW1xLS0x0dXdmZ2hgYGFWV1iUlZi4ur6cnqJ/f4KjpaigoqWqq65iY2VNTk+1t7uZm56MjpHIys6PkZTDxcl2d3nEx8qvsbWztLi+wcRpa21yc3Ui2JSVAAAHrklEQVR42uzZ6XKaYACF4dPjxyYgAQUBjeK+xqhJev+XVnBrKVjSZoZu3/Mng8RTM69oY/BJ+jdAkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJkiRJqp2i4CN68w6k3281OdBcO/h1I6r4BULgb6fgPjt4WduokRWZCz+ehfgJEx/famlv+Hmh28dfR3ldfnt0eMBdAaOdQI1afMTPchfIEfh5ynqNv4+Vf/mJnxzcYzx5qNWIFu5RLIErYXm4ctuovE/+qOiRTeQ4Cs70ro33ql4QTihgC1TTLQAVj8FigG906OMOwTZqZO82LiebTbwEHoxIBTpG9JweID4YnZFGrYWTcKaRr9OXKaD3ls/jZWp1PuNG0XOCM7F3Sa2dILdQRrimh5Pmc/TcEeqYZgOAaLokX3o4Gc7d9SjcH9KHVKpywd5qpPmiqRWvD9G6uyCNHvDdwijdnmKV/pCuBeehyckydWv+ojko53GGGnlrQ+OzYRhTwAq4AaxtzPQAywU1bRRrHCL1oDF9MzXICdDiRSSQ0oPdjAOcKG0eWwP1QDW/UGJ5+0FXQXr/GRcTrQ2IGV1/MHpiC6ltGqGtaWtuQ5SpXpjQTxJV4wg/1BpTM/wFsy75hcGCbgJvx7GqYM6LCS5U+ijncI56BQxxYW6QsjhFqsm2DiSnB+0ZZpZDb3MOiH7fWPdTDi4eriV97sTp+cFefqEoZhNXQ0bjENBtYM9FtuBo5gp44zEEvAmpo1TlgtAWSPUNHz8WcyuAKR/x3QLEJL1RP7oOAL3/wFE/ZeOiw5e7DylGhdpKLgGIwxrAZ6rIeO4u/z6ZLylMQ0Em4Ty/UNRmgqshjx7OXLOLjE8VGJshUrZ7r2TlAgwt0QF4emVJLytOv7AAEbPRdq3S90ko1ATKWAvuUaG2kh2k2mMAIyY4UcSPSvavl5/Q3PxCUcTwmw4POLNpGicHxrCvz/dRdcnyBaBJpje0G5UltXOXXWHhlDIKUV4SER2U2GkMFFSrv2QHN/dLrri5ljQqSiqkXtLB46t61ljB4eWf2VaXLF9I9f3JwiUX4p0liwtQFib390qOmaDEnOajQE2KJbUjUp1iyT1buY9lxuPSkorpikvSedU1+USrpAOeI4Gbg+YhJdbXkqHvq8ipWMBn+/L6HBYWyksWFqDMov6ODZw43CLnwBBlrDmbqEmx5JgOIDbFkk701EWqNx4h09ZObz5N61Yy97Gd3eayqmSbnbIOWzaQcRoJEHCuA8K/Xb8BGSOnYsHjREFqxrCwcK9kfgHK/KkDseUUGYULpMKmjcsxFZTqMUaNlEbQ5i4I1BCpgK9+YJhcDIDenLsOlL0RtXRgQG3bbM2o9ZDZc91SFyabgDNV1ZgTVVX7gD7m7K23dznCdwsF8bU+muqGm/T+ncvVM38bBm2TLUA50tiMxtrtmjySXeRULHjkS7PT83nEjxfWZsOBNU2/+7uFtxlnXaD5zJGD1Jyzz/7LbaVL98/4LcSJeGI2kdJjkpOVxhdgQpoBrPT8UwdA50hSi0OcTQ+kNhkCGJq8aAGwA43k6xvw3ULB5+tTVrzyTEVG32aDT6MEKdF40dxN17+U1MkJcqoWFNMwmJo4+NGCYpDaEAONdJXcgvJMmlPYr+nxECl7o5HGro+zFnd/xicDN9UflOmd3DnLEigjrI6Hd7Czd6NSIuw4+VPXkkNyhZzKBUuBs+rrAH5+4e45BzdtdlFOcIH/w55LVMqX9DnHBxQWPs76wd7zQcF/wTYWeA8rSTZMlOv/kj6gsPBxvrnCPTu66t//F9j3SMwQ7/DKzCNS1gAfUFj4OCX6jLu82DB0/BcsG+/QfUj1bPyRQkiSJEmSJEmSJEmSJEnSH+gReS0FZZwhTsIE0p+pgTwnuyFpXd0C60DiAN0HSLXSE3wleuLdJTHoAEK5mOJMyZKqQpasX/wkcNPk6p0lPQCBUjz7ZmUnIEvWLuQWN8JdC3xv2TibXb76yrWcpxdLTgE4e1myflvTws2AbyhofPf10b4dFb9rMATwFmTB40aqCakenhbjq+Or+JmSdtDITJPbWWvSA8QU8pqsncoVbnp8xM+U9JrI6M3rWeGvesCyK0vWzo5m+GoW2R8r+Wj1exANyJK12zPBzYoqPlSy00Na0rFkydqJ1yO+2mjeT5ZsWJn+taSCrCQgS9bujUvchOYWZRrK2VQ5a30tORpkmteSkCV/E7H+0t697TQIRFEY3m7AFEmhgVLTaDUg4hGjff+HM1VjWkeTxqaB2fzfDeF6hcOCzOw6dPqIo1l9ar+ON87ddTfJPP1QVunGheD4rvXM6SP/eU5yTfbtLo6cPuKa/kgyEpIcmLkGbh/5W+CcTapgo7kiyX613cTtI/snuYUke3Wui90+QpKeWnWZfLvU2WFJNiTZmzCTLZkckOTsNbh3kqR/DFW2zxa24UiW+QIAAAAAAAAAAACAYXm9bvj7a0FULTUQWJAlPs5mxS/qpcCEQsexg759hfLKY8OtzgUWnGqbCQyInrUrBf4L00SfBP5Ldf0gMKBVFtvYUOhAh1aBLwMj9dgJLJgmtcB/YRnrQuC//C1+GcngUgAAAAAAAAAAAAAAxuMENpCkFSRpBUla8Q691KPXmy8iNAAAAABJRU5ErkJggg==",T=JSON.parse('{"title":"NodeJs 异步编程","description":"","frontmatter":{},"headers":[],"relativePath":"other/node-async.md","filePath":"other/node-async.md","lastUpdated":1688130736000}'),s={name:"other/node-async.md"},c=o('<h1 id="nodejs-异步编程" tabindex="-1">NodeJs 异步编程 <a class="header-anchor" href="#nodejs-异步编程" aria-label="Permalink to &quot;NodeJs 异步编程&quot;">​</a></h1><h2 id="异步i-o" tabindex="-1">异步I/O <a class="header-anchor" href="#异步i-o" aria-label="Permalink to &quot;异步I/O&quot;">​</a></h2><ul><li>基于事件驱动的非阻塞I/O模型</li><li>异步I/O调用</li></ul><p><img src="'+a+'" alt="o.png"></p><h2 id="同步i-o" tabindex="-1">同步I/O <a class="header-anchor" href="#同步i-o" aria-label="Permalink to &quot;同步I/O&quot;">​</a></h2><ul><li>同步I/O调用 <img src="'+t+'" alt="o.png"></li></ul><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><ol><li>异常处理 <ol><li>对异步API的执行，try/catch无法捕获</li></ol></li><li>函数嵌套过深 <ol><li>回调函数中的回调函数</li></ol></li><li>阻塞代码 <ol><li>由于Node是单线程事件循环，当阻塞代码出现，将会影响之后的业务逻辑</li></ol></li><li>多线程编程 <ol><li>由于Node是单线程的，无法享受到多核CPU的好处</li><li>使用web sorkers，可以很好利用多核CPU为大量计算服务</li></ol></li><li>异步转同步</li></ol><p><img src="'+r+'" alt="o.png"></p><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><ol><li>事件发布/订阅模式 <ol><li>Node自身的events模块，是事件发布/订阅模式的一个简单实现 <ol><li>不存在事件冒泡等，通过事件监听触发方法实现</li></ol></li><li>addListener/on(): 监听/侦听事件</li><li>emit(): 发布事件</li><li>once(): 侦听一次</li><li>removeListener(): 移除侦听事件</li><li>removeAllListener(): 移除所有的侦听事件</li></ol></li><li>promise/deferred模式 <ol><li>promise操作只会处于3种状态的一种：未完成状态、完成状态、失败状态</li><li>状态只会从未完成状态-&gt;完成状态/失败状态</li><li>状态一旦转化，将不能被更改</li></ol></li><li>流程控制库 <ol><li>尾触发与next</li><li>通过next手动调用，触发函数流程</li></ol></li></ol><p><img src="'+n+'" alt="o.png"></p><h2 id="async模块-流程控制库" tabindex="-1">async模块（流程控制库） <a class="header-anchor" href="#async模块-流程控制库" aria-label="Permalink to &quot;async模块（流程控制库）&quot;">​</a></h2><ol><li>串行执行：async.series([function, function], function(err, result)) <ol><li>将异步回调，组成一组任务串行执行，避免了无限回调的存在</li></ol></li><li>并行执行：async.parallel([function, function],function(err, result)) <ol><li>将一组任务并行执行，同时调用数组中的函数</li></ol></li><li>串行执行(能够传递上一个函数的参数)：async.waterfall([function, function], function(err, result)) <ol><li>和series一样，但是该waterfall方法</li><li>能够将参数传入回调函数，下一个函数能够在形参中接收 <ol><li>通过callback(err, content)传递</li></ol></li></ol></li></ol><h2 id="step模块-流程控制库" tabindex="-1">step模块（流程控制库） <a class="header-anchor" href="#step模块-流程控制库" aria-label="Permalink to &quot;step模块（流程控制库）&quot;">​</a></h2><ol><li>串行执行(能够传递上一个函数的参数)：step(function, function, function done(err, content)) <ol><li>如：fs.readfile(&#39;file.txt&#39;, &#39;utf-8&#39;, this)通过this传递，将异步调用的结果传递给下一个任务</li></ol></li><li>并行执行：step(function, function done(err, content)) <ol><li>如：fs.readfile(&#39;file.txt&#39;, &#39;utf-8&#39;, this.parallel())通过this.parallel()传递，告诉step，需要等待所有任务完成时才进行下一个任务</li><li>this.group()，与this.parallel()相似，区别在于返回结果，是存入在数组中</li></ol></li></ol>',16),d=[c];function A(h,p,m,u,f,k){return e(),i("div",null,d)}const J=l(s,[["render",A]]);export{T as __pageData,J as default};
