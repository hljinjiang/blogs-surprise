import{_ as e,c as t,o as n,a as i}from"./app.212a314b.js";const s="/assets/async_io.f371b038.png",a="/assets/await_io.e20831cf.png",g=JSON.parse('{"title":"NodeJs 异步编程","description":"","frontmatter":{},"headers":[{"level":2,"title":"异步I/O","slug":"异步i-o","link":"#异步i-o","children":[]},{"level":2,"title":"同步I/O","slug":"同步i-o","link":"#同步i-o","children":[]}],"relativePath":"other/node-async.md","lastUpdated":1679023678000}'),o={name:"other/node-async.md"},r=i('<h1 id="nodejs-异步编程" tabindex="-1">NodeJs 异步编程 <a class="header-anchor" href="#nodejs-异步编程" aria-hidden="true">#</a></h1><h2 id="异步i-o" tabindex="-1">异步I/O <a class="header-anchor" href="#异步i-o" aria-hidden="true">#</a></h2><ul><li>基于事件驱动的非阻塞I/O模型</li><li>异步I/O调用</li></ul><p><img src="'+s+'" alt="o.png"></p><h2 id="同步i-o" tabindex="-1">同步I/O <a class="header-anchor" href="#同步i-o" aria-hidden="true">#</a></h2><ul><li>同步I/O调用 <img src="'+a+'" alt="o.png"></li></ul><p>1 难点 异常处理 对异步API的执行，try/catch无法捕获 函数嵌套过深 回调函数中的回调函数 阻塞代码 由于Node是单线程事件循环，当阻塞代码出现，将会影响之后的业务逻辑 多线程编程 由于Node是单线程的，无法享受到多核CPU的好处 使用web sorkers，可以很好利用多核CPU为大量计算服务</p><p>异步转同步 解决方案 事件发布/订阅模式 Node自身的events模块，是事件发布/订阅模式的一个简单实现 不存在事件冒泡等，通过事件监听触发方法实现 addListener/on() 监听/侦听事件 emit() 发布事件 once() 侦听一次 removeListener() 移除侦听事件 removeAllListener() 移除所有的侦听事件 promise/deferred模式 promise操作只会处于3种状态的一种：未完成状态、完成状态、失败状态 状态只会从未完成状态-&gt;完成状态/失败状态 状态一旦转化，将不能被更改 流程控制库 尾触发与next 通过next手动调用，触发函数流程</p><p>async模块（流程控制库） 串行执行：async.series([function, function], function(err, result)) 将异步回调，组成一组任务串行执行，避免了无限回调的存在 并行执行：async.parallel([function, function],function(err, result)) 将一组任务并行执行，同时调用数组中的函数 串行执行(能够传递上一个函数的参数)：async.waterfall([function, function], function(err, result)) 和series一样，但是该waterfall方法 能够将参数传入回调函数，下一个函数能够在形参中接收 通过callback(err, content)传递 step模块（流程控制库） 串行执行(能够传递上一个函数的参数)：step(function, function, function done(err, content)) 如：fs.readfile(&#39;file.txt&#39;, &#39;utf-8&#39;, this)通过this传递，将异步调用的结果传递给下一个任务 并行执行：step(function, function done(err, content)) 如：fs.readfile(&#39;file.txt&#39;, &#39;utf-8&#39;, this.parallel())通过this.parallel()传递，告诉step，需要等待所有任务完成时才进行下一个任务 this.group()，与this.parallel()相似，区别在于返回结果，是存入在数组中</p>',9),l=[r];function c(d,f,p,h,u,_){return n(),t("div",null,l)}const x=e(o,[["render",c]]);export{g as __pageData,x as default};
