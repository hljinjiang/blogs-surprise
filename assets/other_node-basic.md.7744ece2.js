import{_ as s,o as n,c as a,U as l}from"./chunks/framework.76b79cb5.js";const o="/assets/node_module_cache.b2b3e3c1.png",e="/assets/continue_io.a2e35e78.png",p="/assets/async.790ec189.png",t="/assets/settime.dfa5c865.png",i="/assets/event_loop.ee8e32ad.png",f=JSON.parse('{"title":"NodeJs","description":"","frontmatter":{},"headers":[],"relativePath":"other/node-basic.md","filePath":"other/node-basic.md","lastUpdated":1690425569000}'),r={name:"other/node-basic.md"},c=l(`<h1 id="nodejs" tabindex="-1">NodeJs <a class="header-anchor" href="#nodejs" aria-label="Permalink to &quot;NodeJs&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">简介</p><p>读取《Node 深入浅出》后的总结<br> NodeJs 是一个基于Chrome V8引擎的JavaScript运行环境</p><ol><li>非阻塞异步I/O</li><li>事件驱动/回调函数</li><li>单线程</li><li>跨平台</li></ol></div><h2 id="模块机制" tabindex="-1">模块机制 <a class="header-anchor" href="#模块机制" aria-label="Permalink to &quot;模块机制&quot;">​</a></h2><h3 id="commonjs模块化" tabindex="-1">commonJS模块化 <a class="header-anchor" href="#commonjs模块化" aria-label="Permalink to &quot;commonJS模块化&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#88846F;">// math.js</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">exports</span><span style="color:#F8F8F2;">.</span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> () {</span></span>
<span class="line"><span style="color:#F8F8F2;">  console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;hello&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// or</span></span>
<span class="line"></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">module</span><span style="color:#F8F8F2;">.</span><span style="color:#66D9EF;font-style:italic;">exports</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;">: </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> () {</span></span>
<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;hello&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">  },</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// index.js</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> math </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">require</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;./math&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">math.</span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="模块的实现" tabindex="-1">模块的实现 <a class="header-anchor" href="#模块的实现" aria-label="Permalink to &quot;模块的实现&quot;">​</a></h3><ol><li><strong>路径分析</strong><ol><li>通过文件路径或名字获取模块的引用</li><li>优先从缓存加载（之前 require 的模块会被缓存，再次引入优先加载缓存模块）</li><li><strong>Node核心模块</strong>: <code>require(&#39;http&#39;)</code>，此为 Node 内置模块</li><li><strong>node_modules模块</strong>: <code>require(&#39;build-zip&#39;)</code>，Node将试图去当前目录的node_modules文件夹里搜索</li><li><strong>文件模块</strong>: <code>require(&#39;/home/base/my_mod&#39;)</code> or <code>require(&#39;./my_mod&#39;)</code><ol><li>require导入文件时，如果不添加后缀名，则会按照.js，.json，.node等的顺序添加</li></ol></li><li><strong>文件目录模块</strong>: <code>require(&#39;./folder&#39;)</code><ol><li>如果folder目录里没有包含package.json文件</li><li>Node会假设默认主文件为index.js，即会加载index.js，如果index.js也不存在， 那么加载将失败</li></ol></li><li><strong>自动缓存已载入模块</strong>: 对于已加载的模块Node会缓存下来</li></ol></li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#88846F;">// math.js</span></span>
<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;init&quot;</span><span style="color:#F8F8F2;">);    </span><span style="color:#88846F;">// 只执行一次</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">module</span><span style="color:#F8F8F2;">.</span><span style="color:#66D9EF;font-style:italic;">exports</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;">: </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> () {</span></span>
<span class="line"><span style="color:#F8F8F2;">    console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;hello&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">  },</span></span>
<span class="line"><span style="color:#F8F8F2;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// index.js</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> math </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">require</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;./math&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> math1 </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">require</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;./math&quot;</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">math.</span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">math1.</span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><img src="`+o+`" alt="o.png"></p><ol start="2"><li><strong>文件定位</strong><ol><li><strong>文件路径分析</strong><ol><li>文件二次引入不需要路径分析，读取缓存</li><li>文件名不包含扩展名的情况下，Node会按照<code>.js</code>、<code>.json</code>、<code>.node</code>的次序补充扩展名，依次尝试</li><li>在尝试的过程中，还会调用fs模块同步阻塞地判断文件是否存在，Node是单线程的，所以这里会引起性能问题，因此对<code>.node</code>和<code>.json</code>等文件，需要在require时加上<code>扩展名</code></li></ol></li><li><strong>目录分析和包</strong><ol><li>在require()通过分析文件定位分析，可能没有对应文件，确定位到一个目录，此时Node会将目录当做一个包来处理</li><li>首先，Node会在该目录查找package.json通过JSON.parse()即系包描述对象，从中取出main属性指定的文件名进行定位，如果文件名缺少扩展名，又会进行补充扩展名分析步骤</li><li>如果main属性指定错误，或者根本没有pakeage.json文件，Node会默认将index当做模块文件名，然后依次查找index.js、.json、.node</li></ol></li></ol></li><li><strong>模块编译</strong><ol><li>每个文件模块都是一个对象 <ol><li><code>.js</code>: 通过fs模块同步读取文件后编译执行。</li><li><code>.node</code>: 这是C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件</li><li><code>.json</code>: 同过fs模块同步读取文件后，用JSON.pares()解析返回结果</li><li><code>其他扩展名文件</code>: ，都当作.js文件载入</li></ol></li><li>每个编译成功的模块都会将文件路径作为索引缓存在Module._cahce对象上，以提高二次引入的性能</li><li>Node对每个模块文件包装了一层函数，进行作用域隔离，因此模块中会有<code>以下参数存在</code></li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> (</span><span style="color:#FD971F;font-style:italic;">exports</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">require</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">module</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">__filename</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">__dirname</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">   </span><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> math </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">require</span><span style="color:#F8F8F2;">(‘math‘);</span></span>
<span class="line"><span style="color:#F8F8F2;">   </span><span style="color:#66D9EF;font-style:italic;">exports</span><span style="color:#F8F8F2;">.</span><span style="color:#A6E22E;">area</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">radius</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> Math.PI </span><span style="color:#F92672;">*</span><span style="color:#F8F8F2;"> radius </span><span style="color:#F92672;">*</span><span style="color:#F8F8F2;"> radius;</span></span>
<span class="line"><span style="color:#F8F8F2;">   }</span></span>
<span class="line"><span style="color:#F8F8F2;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ol><h2 id="非阻塞i-o" tabindex="-1">非阻塞I/O <a class="header-anchor" href="#非阻塞i-o" aria-label="Permalink to &quot;非阻塞I/O&quot;">​</a></h2><ol><li><p><strong>阻塞I/O</strong></p><ol><li>一定会等到系统内核层面完成所有操作后，调用才结束</li><li>以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束</li><li>阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用</li></ol></li><li><p><strong>非阻塞I/O</strong></p><ol><li>内核在进行 I/O 读写函数后，立即返回</li><li>非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，此时性能提升是明显的</li><li>由于完整的I/O并没有完成，立即返回的只是当前调用的状态，并不是业务层期望的数据</li><li>要获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成</li><li>这种重复调用判断操作是否完成的技术叫轮询</li><li>等待完成后，将立即执行返回的回调函数 <img src="`+e+'" alt="o.png"></li></ol></li></ol><p><code>非阻塞I/O</code>只返回状态，需要通过重复请求轮询操作判断数据是否返回完成</p><h2 id="异步i-o" tabindex="-1">异步I/O <a class="header-anchor" href="#异步i-o" aria-label="Permalink to &quot;异步I/O&quot;">​</a></h2><p><img src="'+p+'" alt="o.png"></p><p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素</p><h2 id="非i-o的异步api" tabindex="-1">非I/O的异步API <a class="header-anchor" href="#非i-o的异步api" aria-label="Permalink to &quot;非I/O的异步API&quot;">​</a></h2><ul><li>setTimeout</li></ul><p><img src="'+t+'" alt="o.png"></p><ul><li><p>setInterval</p><ul><li>循环的调用定时器</li><li>定时器性能消耗较大，使用的是红黑树</li></ul></li><li><p>process.nextTick()</p><ul><li>主线程事件循环进行一次完整的行程时，称为一个滴答</li><li>将回调函数传入后，会在下一个事件循环之前调用该函数</li></ul></li><li><p>setImmediate</p><ul><li>功能和process.nextTick()相同作用</li><li>差别 <ul><li>setImmediate: 属于check观察者</li><li>process.nexTick: 属于idle观察者</li><li>在每一个轮循环检查中，idle观察者 先于 I/O观察者，I/O观察者 先于 check观察者</li></ul></li></ul></li></ul><h2 id="事件驱动" tabindex="-1">事件驱动 <a class="header-anchor" href="#事件驱动" aria-label="Permalink to &quot;事件驱动&quot;">​</a></h2><ul><li>通过主循环 + 事件触发的方式来运行程序</li></ul><p><img src="'+i+'" alt="o.png"></p>',23),F=[c];function d(y,u,m,b,h,g){return n(),a("div",null,F)}const _=s(r,[["render",d]]);export{f as __pageData,_ as default};
