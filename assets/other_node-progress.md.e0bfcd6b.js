import{_ as l,c as i,o as e,O as o}from"./chunks/framework.d7e37bdc.js";const a="/assets/node-progress.dcafe91e.png",m=JSON.parse('{"title":"Node 进程","description":"","frontmatter":{},"headers":[],"relativePath":"other/node-progress.md","filePath":"other/node-progress.md","lastUpdated":1685190826000}'),r={name:"other/node-progress.md"},t=o('<h1 id="node-进程" tabindex="-1">Node 进程 <a class="header-anchor" href="#node-进程" aria-label="Permalink to &quot;Node 进程&quot;">​</a></h1><h2 id="服务模型" tabindex="-1">服务模型 <a class="header-anchor" href="#服务模型" aria-label="Permalink to &quot;服务模型&quot;">​</a></h2><ol><li>同步（进程 = 1） <ol><li>一次只为一个请求服务，所有请求按次序等待服务</li><li>请求执行非常缓慢，无并发</li><li>QPS = 1/N</li></ol></li><li>复制进程（进程 = M） <ol><li>复制N个进程，一个进程一次处理一个请求服务</li><li>请求执行消耗大量内存，一旦并发过高，随着进程增多导致内存耗尽</li><li>QPS = M/N</li></ol></li><li>多线程（进程 = L，线程 = M） <ol><li>将一个进程拆分为多个线程，线程之间可以共享数据</li><li>与复制进程相比，节约了内存资源</li><li>Apache就是采用多线程/多进程，但当并发上万时内存耗用则会暴露出来</li><li>QPS = L * M/N</li></ol></li><li>事件驱动 <ol><li>由于单进程、单线程的原因，请求趋于稳定性</li><li>影响事件驱动服务模型性能的点在于CPU的计算能力</li><li>CPU的上限决定了事件驱动服务模型性能的上限</li><li>不受内存资源的上限，可伸缩性比前两者较高</li></ol></li></ol><h2 id="多进程架构" tabindex="-1">多进程架构 <a class="header-anchor" href="#多进程架构" aria-label="Permalink to &quot;多进程架构&quot;">​</a></h2><ol><li>在理想状态下，每个进程各自利用一个CPU，以此实现多核CPU的利用</li><li>在Node中提供了child_process模块，实现进程的复制</li><li>主从模式（Master-Worker） <ol><li>这是典型的分布式架构中用于并行处理业务的模式 <img src="'+a+'" alt="o.png"></li><li>每个进程都有独立的V8实例，启动需要30毫秒和至少10M的内存</li><li>这里启动多个进程只是为了充分将CPU资源利用起来，并不是为了解决并发问题</li></ol></li><li>使用child_process创建子进程 <ol><li>spawn：启动一个子进程来执行命令</li><li>exec：启动一个子进程来执行命令，拥有一个回调函数获知子进程状况</li><li>execFile：启动一个子进程来执行可执行文件</li><li>fork：启动一个子进程，只需指定要执行的JavaScript文件模块即可</li></ol></li><li>进程间通信 <ol><li>通过process监听child_process创建的子进程发送的消息</li><li>在创建child_process时，父进程在实际创建子进程之前，会创建IPC通道并监听它</li></ol></li></ol><h2 id="集群" tabindex="-1">集群 <a class="header-anchor" href="#集群" aria-label="Permalink to &quot;集群&quot;">​</a></h2><ol><li>一组独立的计算系统构成一个松耦合多处理系统，之间通过网络通信实现消息传送</li><li>Node的一组子进程构成了集群，通过上面的主从模式并行处理业务</li><li>进程事件</li><li>自动重启</li><li>负载均衡</li><li>状态共享</li></ol><h2 id="cluster-node集群" tabindex="-1">Cluster（Node集群） <a class="header-anchor" href="#cluster-node集群" aria-label="Permalink to &quot;Cluster（Node集群）&quot;">​</a></h2><ol><li>使用cluster可以更容易的实现集群</li><li>cluster模块就是child_process模块和net模块的组合应用</li><li>采用主从模式处理业务</li></ol>',9),s=[t];function d(c,n,h,_,p,u){return e(),i("div",null,s)}const f=l(r,[["render",d]]);export{m as __pageData,f as default};
