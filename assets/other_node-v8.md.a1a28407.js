import{_ as l,c as i,o as e,a}from"./app.d860d55d.js";const o="/assets/v8_new.b97d318d.png",n="/assets/v8_new_one.4eb65120.png",t="/assets/v8_new_two.34dc046b.png",r="/assets/v8_old_one.396b297f.png",s="/assets/v8_incremental_marking.dd5bfe0c.png",V=JSON.parse('{"title":"Node V8内存控制","description":"","frontmatter":{},"headers":[{"level":2,"title":"基础","slug":"基础","link":"#基础","children":[]},{"level":2,"title":"内存分配（V8堆的大小）","slug":"内存分配-v8堆的大小","link":"#内存分配-v8堆的大小","children":[]},{"level":2,"title":"增量标记（Incremental Marking）","slug":"增量标记-incremental-marking","link":"#增量标记-incremental-marking","children":[]}],"relativePath":"other/node-v8.md","lastUpdated":1679462833000}'),c={name:"other/node-v8.md"},d=a('<h1 id="node-v8内存控制" tabindex="-1">Node V8内存控制 <a class="header-anchor" href="#node-v8内存控制" aria-hidden="true">#</a></h1><h2 id="基础" tabindex="-1">基础 <a class="header-anchor" href="#基础" aria-hidden="true">#</a></h2><ol><li>Node基于V8引擎使用内存，使用c++编译 <ol><li>V8具有内存限制</li><li>原因是最初是对浏览器而设计的，不需要太大的内存 <ol><li>内存使用过多就会崩溃（没有足够的内存，内存溢出）</li><li>对象不再使用，而没有被销毁，内存一直没有被释放（内存泄漏）</li></ol></li></ol></li><li>V8垃圾回收机制算法 <ol><li>对不同对象的存货时间将内存的垃圾回收进不同的分代</li><li>对不同分代的内存使用更高效的回收算法</li></ol></li></ol><h2 id="内存分配-v8堆的大小" tabindex="-1">内存分配（V8堆的大小） <a class="header-anchor" href="#内存分配-v8堆的大小" aria-hidden="true">#</a></h2><p><img src="'+o+'" alt="o.png"></p><ol><li><p>新生代的内存空间（生命周期短）</p><ol><li>采用cheney算法，一种复制的方式实现垃圾回收算法</li><li>先是在From空间中进行分配，检测在From空间中的存活对象</li><li>存活对象将被复制到To空间，而非存活对象占用的空间将会被释放（闭包则不会被释放）</li><li>随后进行翻转，To -&gt; From，From到To之前将会进行一次检测，在一定条件下将存活周期长的对象移入老生代</li><li>晋升的条件主要有两个：是否经历过回收依然未被释放，To空间的内存占用超过限制 <img src="'+n+'" alt="o.png"><img src="'+t+'" alt="o.png"></li></ol></li><li><p>老生代的内存空间（生命周期长）</p><ol><li>当一个对象经过多次复制依然存活时，它被认为是生周期较长的对象，将会移入到老生代中（称为晋升）</li><li>采用Mark-Sweep标记清除 <ol><li>标记阶段：遍历堆中的所有对象，并标记活着的对象</li><li>清除阶段：只清除没有被标记的对象</li></ol></li><li>结合Mark-Compact标记整理 <ol><li>在标记对象死亡后，在整理过程中，将活着的对象往一端移动</li><li>移动完成后，直接清理掉边界外的内存 <img src="'+r+'" alt="o.png"></li></ol></li></ol></li></ol><h2 id="增量标记-incremental-marking" tabindex="-1">增量标记（Incremental Marking） <a class="header-anchor" href="#增量标记-incremental-marking" aria-hidden="true">#</a></h2><ol><li>为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）</li><li>增量标记：使垃圾回收最大停顿时间可以减少到原本的1/6左右 <img src="'+s+'" alt="o.png"></li><li>延迟清理</li><li>增量式清理</li><li>并行标记、并行清理: 利用多核性能降低每次停顿时间</li></ol>',8),_=[d];function p(h,m,g,v,k,f){return e(),i("div",null,_)}const T=l(c,[["render",p]]);export{V as __pageData,T as default};
