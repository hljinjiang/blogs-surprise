import{_ as t,c as o,o as a,b as e,d as n}from"./app.b2a11054.js";const C=JSON.parse('{"title":"Node Web应用","description":"","frontmatter":{},"headers":[],"relativePath":"other/node-web.md","lastUpdated":1680008827000}'),r={name:"other/node-web.md"},d=e("h1",{id:"node-web应用",tabindex:"-1"},[n("Node Web应用 "),e("a",{class:"header-anchor",href:"#node-web应用","aria-hidden":"true"},"#")],-1),s=e("p",null,'基础功能 请求方法 get、post、delete、put 路径解析 GET /path?foo=bar HTTP/1.1（查询字符串） GET路径的hash部分会被丢弃 通过url.parse()解析url的path Cookie 用于标识和认证一个用户 处理步骤： 服务器 ----》客户端，发送Cookie 浏览器将Cookie保存 之后每次浏览器都会将Cookie发向 ----》服务器端 数据上传 上传方式 application/x-www-form-urlencoded：默认，发送前对所有字符编码，原生form表单 参数：foo=bar&baz=val multipart/form-data：指定表单属性enctype为前面参数，上传文件时使用 解析为二进制进行传输 application/json：使用序列化后的JSON字符串，数据上传方式 参数：{ "key":"value" } text/plain：将空格编码“+”符号，但不编码特殊字符 数据上传与安全 内存限制 对请求报文的字段Content-Length进行分析，超过长度限制则直接响应413 若没有Contnet-Length请求报文，则通过data事件中的请求字段判定即可 CSRF 通过获得受信网站的cookie，伪造身份进行请求接口，前提是获得身份认证cookie 路径解析 文件路径型 静态文件 URL路径和文件路径一致，服务端直接将请求路径对应的文件发送给客户端渲染即可 动态文件 根据URL路径自动查找对应文件 MVC MVC模型实现是将业务逻辑按职责分离 控制器（controller）：一组行为逻辑的集合 模型（model）:数据相关操作和封装 视图（view）：视图的渲染 分层模式',-1),i=e("p",null,"路由解析：根据URl寻找对应控制器 控制器执行相关行为，进而操作数据 数据操作结束后，根据数据的变动渲染视图，输出到客户端 中间件（middleware） 是什么 提供系统软件和应用软件之间连接、便于软件各部件之间沟通的软件 处于操作系统与应用软件之间 中间件封装底层细节，为上层提供更方便服务的意义 为什么 开发便捷、开箱即用的服务、减少运行成本 页面渲染 内容响应 MIME（媒体类型） 浏览器针对不同的MIME会采用不同的处理方式 如Content-Type：text/plain 会处理显示成纯文本 如Content-Type：text/html 会处理显示成HTML，并渲染DOM树 如Content-Type：application/json 会处理解析成JSON格式",-1),l=[d,s,i];function p(c,h,_,m,u,f){return a(),o("div",null,l)}const k=t(r,[["render",p]]);export{C as __pageData,k as default};
