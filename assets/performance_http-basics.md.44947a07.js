import{_ as t,c as s,o as l,a as r}from"./app.b206d50e.js";const n="/docs-surprise/assets/protocol-all.32ad7fcc.png",a="/docs-surprise/assets/protocol.7b493f4d.png",o="/docs-surprise/assets/Aspose.Words.417e3b11-1720-4c92-af80-ff130734d73b.010.32aa8872.jpeg",e="/docs-surprise/assets/Aspose.Words.417e3b11-1720-4c92-af80-ff130734d73b.001.9cac8af2.png",p="/docs-surprise/assets/WX20230104-095243@2x.79be220e.png",i="/docs-surprise/assets/clipboard.71a56f5f.png",d="/docs-surprise/assets/Aspose.Words.3443b485-1533-46e9-8ef5-fddf78953ed1.001.9beace56.png",c="/docs-surprise/assets/Aspose.Words.3443b485-1533-46e9-8ef5-fddf78953ed1.002.d98440b5.png",g="/docs-surprise/assets/Aspose.Words.417e3b11-1720-4c92-af80-ff130734d73b.007.9d8336cc.jpeg",F="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtQAAAAiCAYAAAB/eU7dAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBD6fLggAAAUtJREFUeJzt2jFKQ0EUhtE7j4dIIDuwSCotBLdg4SJcootwDyoIwSoWaQOBQBAT3lglpPYWkwfnVDNT/eVXTAQAAAAAALRQjoflcnm93f7OGm4BAIBRmE6vvufz+U9ERH983Oz2d10pT1Hqqt00AAC4cLXcbHb714h4jzgL6oiIKHX1cH/70mIXAACMwcfn1/PZR4/oGm4BAIDRE9QAAJAgqAEAIEFQAwBAgqAGAIAEQQ0AAAmCGgAAEgQ1AAAkCGoAAEgQ1AAAkCCoAQAgQVADAECCoAYAgARBDQAACYIaAAASBDUAACQIagAASBDUAACQIKgBACBBUAMAQIKgBgCABEENAAAJghoAABIENQAAJPTnl1rr5G2xmDXaAgAAF68e6iRKOd1PQd0P3frQxRBDPLYYBgAAY1C7GPqhW7feAQAAAAAAAADAv/0Bz/cqqov7/PUAAAAASUVORK5CYII=",A="/docs-surprise/assets/Aspose.Words.417e3b11-1720-4c92-af80-ff130734d73b.011.6fe72833.jpeg",h="/docs-surprise/assets/Aspose.Words.417e3b11-1720-4c92-af80-ff130734d73b.012.168f6b94.jpeg",b="/docs-surprise/assets/Aspose.Words.417e3b11-1720-4c92-af80-ff130734d73b.013.8b683ffe.png",y="/docs-surprise/assets/Aspose.Words.3443b485-1533-46e9-8ef5-fddf78953ed1.003.c572fb24.png",E=JSON.parse('{"title":"Http Basics","description":"","frontmatter":{},"headers":[{"level":2,"title":"网络模型","slug":"网络模型","link":"#网络模型","children":[]},{"level":2,"title":"URI","slug":"uri","link":"#uri","children":[]},{"level":2,"title":"应用层-HTTP","slug":"应用层-http","link":"#应用层-http","children":[]},{"level":2,"title":"HTTP报文","slug":"http报文","link":"#http报文","children":[]},{"level":2,"title":"HTTP状态码","slug":"http状态码","link":"#http状态码","children":[]},{"level":2,"title":"HTTP方法","slug":"http方法","link":"#http方法","children":[]},{"level":2,"title":"传输层-TCP","slug":"传输层-tcp","link":"#传输层-tcp","children":[]},{"level":2,"title":"TCP 握手","slug":"tcp-握手","link":"#tcp-握手","children":[{"level":3,"title":"建立连接","slug":"建立连接","link":"#建立连接","children":[]},{"level":3,"title":"连接终止","slug":"连接终止","link":"#连接终止","children":[]}]}],"relativePath":"performance/http-basics.md","lastUpdated":1673156843000}'),T={name:"performance/http-basics.md"},C=r('<h1 id="http-basics" tabindex="-1">Http Basics <a class="header-anchor" href="#http-basics" aria-hidden="true">#</a></h1><h2 id="网络模型" tabindex="-1">网络模型 <a class="header-anchor" href="#网络模型" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">简介</p><p>首先我们来看几张图，了解下网络的模型结构<br> 国际标准 OSI模型 有7层结构，广泛应用的 TCP/IP模型 可以分为5层/4层结构</p><p><img src="'+n+'" alt=""><br><img src="'+a+'" alt=""><br><img src="'+o+'" alt=""></p><p>这里主要分析 TCP/IP模型 4层结构</p></div><h2 id="uri" tabindex="-1">URI <a class="header-anchor" href="#uri" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">简介</p><p>URI（<strong>统一资源标识符</strong>）用于标识某一互联网资源名称的字符串<br> URI是一种抽象宽泛的定义。即，不管用什么方法表示，只要能唯一标记某个资源，它就叫URI<br> 通常已http:、ftp:、mailto:、file:，和协议对应的内容所构成</p><ul><li>URL（<strong>统一资源定位符</strong>）用于标识某一互联网资源名称的字符串，URL是URI的一个子集 <ul><li>比如：<a href="http://www.aspxfans.com:8080/news/day01/index.asp?boardID=5&amp;pwd=24618&amp;page=1#name" target="_blank" rel="noreferrer">http://www.aspxfans.com:8080/news/day01/index.asp?boardID=5&amp;pwd=24618&amp;page=1#name</a><ul><li>协议部分 http: (浏览器协议)</li><li>域名部分 <a href="http://www.aspxfans.com" target="_blank" rel="noreferrer">www.aspxfans.com</a> (通过DNS转换为IP，识别主机服务器)</li><li>端口部分 :8080 (识别主机的对应进程)</li><li>目录部分 /news/day01/ (资源路径)</li><li>文件部分 index.asp (查找的对应文件)</li><li>参数部分 boardID=5&amp;pwd=24618&amp;page=1 (参数)</li><li>锚定部分 name (#指定了网页中的一个位置)</li></ul></li></ul></li></ul></div><p>参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL</a></p><h2 id="应用层-http" tabindex="-1">应用层-HTTP <a class="header-anchor" href="#应用层-http" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">简介</p><p>HTTP（<strong>超⽂本传输协议 HyperText Transfer Protocol</strong> ）<br> 每个 HTTP请求都是⽆状态的，可以把 HTTP的⼀次请求当作⼀次事务<br> HTTP是应⽤层通信协议，旨在在联⽹设备之间传输信息，HTTP标准化了客户端和服务器之间的通信⽅式<br> HTTPS：在 HTTP基础上，增加 <strong>传输加密</strong> 和 <strong>身份认证</strong> 保证传输过程的安全性</p></div><div class="info custom-block"><p class="custom-block-title">HTTP结构</p><p><img src="'+e+'" alt=""></p><p><img src="'+p+'" alt=""></p></div><p>参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/HTTP</a></p><h2 id="http报文" tabindex="-1">HTTP报文 <a class="header-anchor" href="#http报文" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">简介</p><p>报文：是网络中交换与传输的数据单元，即站点一次性要发送的数据块<br> HTTP传输分为 <strong>报文首部</strong> 和 <strong>报文主体</strong></p></div><ul><li><strong>请求行</strong><ul><li>HTTP 请求 Method、URI、Version ( GET /URI HTTP/1.1 )</li></ul></li><li><strong>状态行</strong><ul><li>HTTP 响应 Version、Status Code、Reason ( HTTP/1.1 200 OK )</li></ul></li><li><strong>首部字段</strong><ul><li>包含表示请求和响应的各种条件和属性的各类首部</li><li><strong>通⽤⾸部字段</strong>：请求报⽂和响应报⽂两⽅都会使⽤的头部 <table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td><strong>控制缓存的行为</strong></td></tr><tr><td>Connection</td><td><strong>连接管理</strong></td></tr><tr><td>Date</td><td><strong>创建报文的日期时间</strong></td></tr><tr><td>Pragma</td><td><strong>报文指令</strong></td></tr><tr><td>Trailer</td><td><strong>报文末端的首部一览</strong></td></tr><tr><td>Trailer-Encoding</td><td><strong>指定报文主体的传输编码方式</strong></td></tr><tr><td>Upgrade</td><td><strong>升级为其他协议</strong></td></tr><tr><td>Via</td><td><strong>代理服务器的相关信息</strong></td></tr><tr><td>Warning</td><td><strong>错误通知</strong></td></tr></tbody></table></li><li><strong>请求⾸部字段</strong>：从客户端向服务器端发送请求报⽂使⽤的头部 <table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td><strong>用户代理可处理的媒体类型</strong></td></tr><tr><td>Accept-Charset</td><td><strong>优先处理字符集</strong></td></tr><tr><td>Accept-Encoding</td><td><strong>优先的内容编码</strong></td></tr><tr><td>Accept-Language</td><td><strong>优先的语言</strong></td></tr><tr><td>Authorization</td><td><strong>Web认证信息</strong></td></tr><tr><td>Expect</td><td><strong>期待服务器的特定行为</strong></td></tr><tr><td>From</td><td><strong>用户的电子邮箱地址</strong></td></tr><tr><td>Host</td><td><strong>请求资源所在的服务器</strong></td></tr><tr><td>If-Match</td><td><strong>比较实体标记</strong></td></tr><tr><td>If-Modified-Since</td><td><strong>比较资源的更新时间</strong></td></tr><tr><td>If-None-Match</td><td><strong>比较实体标记（与If-Match相反）</strong></td></tr><tr><td>Max-Forwards</td><td><strong>最大传输逐跳数</strong></td></tr><tr><td>Proxy-Authorization</td><td><strong>代理服务器要求客户端的认证信息</strong></td></tr><tr><td>Range</td><td><strong>实体的字节范围请求</strong></td></tr><tr><td>Referer</td><td><strong>对请求中URI的原始获取方</strong></td></tr><tr><td>TE</td><td><strong>传输编码的优先级</strong></td></tr><tr><td>User-Agent</td><td><strong>HTTP客户端程序的信息</strong></td></tr></tbody></table></li><li><strong>响应⾸部字段</strong>：从服务端向客户端返回响应报⽂时使⽤的头部 <table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td><strong>是否接受字节范围请求</strong></td></tr><tr><td>Age</td><td><strong>推算资源创建经过时间</strong></td></tr><tr><td>ETag</td><td><strong>资源的匹配信息</strong></td></tr><tr><td>Location</td><td><strong>令客户端重定向至URI</strong></td></tr><tr><td>Proxy-Authenticate</td><td><strong>代理服务器对客户端的认证信息</strong></td></tr><tr><td>Retry-After</td><td><strong>对再次发器请求的时机要求</strong></td></tr><tr><td>Server</td><td><strong>HTTP服务器的安装信息</strong></td></tr><tr><td>Vary</td><td><strong>代理服务器缓存的管理信息</strong></td></tr><tr><td>WWW-Authenticate</td><td><strong>服务器对客户端的认证信息</strong></td></tr></tbody></table></li><li><strong>实体⾸部字段</strong>：针对请求报⽂和响应报⽂的实体部分使⽤的⾸部（如补充资源内容更新时间等与实体有关的信息） <table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td><strong>资源可支持的HTTP方法</strong></td></tr><tr><td>Content-Encoding</td><td><strong>实体主体适用的编码方式</strong></td></tr><tr><td>Content-Language</td><td><strong>实体主体的自然语言</strong></td></tr><tr><td>Content-Length</td><td><strong>实体主体的大小（单位：字节）</strong></td></tr><tr><td>Content-Location</td><td><strong>替代对应资源的URI</strong></td></tr><tr><td>Content-MD5</td><td><strong>实体主体的报文摘要</strong></td></tr><tr><td>Content-Range</td><td><strong>实体主体的位置范围</strong></td></tr><tr><td>Content-Type</td><td><strong>实体主体的媒体类型</strong></td></tr><tr><td>Expires</td><td><strong>实体主体过期的日期时间</strong></td></tr><tr><td>Last-Modified</td><td><strong>资源的最后修改日期时间</strong></td></tr></tbody></table></li></ul></li></ul><p>参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers</a></p><h2 id="http状态码" tabindex="-1">HTTP状态码 <a class="header-anchor" href="#http状态码" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">简介</p><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果</p></div><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>1xx(信息响应)</td><td>接收的请求正在处理</td></tr><tr><td>2xx(成功响应)</td><td>请求正常处理完毕</td></tr><tr><td>200</td><td>正常处理，请求成功</td></tr><tr><td>204</td><td>请求处理成功，但是没有响应主体</td></tr><tr><td>206</td><td>Content-Range 指定范围的实体内容</td></tr><tr><td>3xx(重定向消息)</td><td>需要进行附加操作以完成请求</td></tr><tr><td>301</td><td>永久重定向 (表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI，会去更新书签的URI)</td></tr><tr><td>302</td><td>临时重定向 (表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问，保留书签对应的URI)</td></tr><tr><td>303</td><td>临时重定向 (表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问，保留书签对应的URI，但应当使用GET请求)</td></tr><tr><td>304</td><td>资源已找到，但未符合条件请求 (比如该请求返回的文件，文件未被修改，对客户端有缓存情况下服务端的一种响应，返回缓存文件)</td></tr><tr><td>4xx(客户端错误响应)</td><td>服务器⽆法处理请求</td></tr><tr><td>400</td><td>请求语法错误</td></tr><tr><td>401</td><td>请求需要账户密码认证</td></tr><tr><td>403</td><td>请求资源的访问被服务器拒绝</td></tr><tr><td>404</td><td>服务器没有找到请求资源</td></tr><tr><td>5xx(服务端错误响应)</td><td>服务器处理请求出错</td></tr><tr><td>500</td><td>服务器发⽣错误</td></tr><tr><td>503</td><td>服务器暂时处于超负载或处于停机维护</td></tr></tbody></table><p>参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></p><h2 id="http方法" tabindex="-1">HTTP方法 <a class="header-anchor" href="#http方法" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">简介</p><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法</p><table><thead><tr><th>请求方法</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>OPTIONS</td><td>用于描述目标资源的通信选项</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><p><img src="'+i+`" alt=""></p></div><p>参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods</a></p><h2 id="传输层-tcp" tabindex="-1">传输层-TCP <a class="header-anchor" href="#传输层-tcp" aria-hidden="true">#</a></h2><div class="info custom-block"><p class="custom-block-title">简介</p><p>TCP（<strong>传输控制协议 Transmission Control Protocol</strong>）<br> 是一个面向连接的、可靠的、基于字节流的传输层协议</p><ul><li>面向连接 <ul><li>客户端和服务器的连接，互相通信之前，TCP 需要三次握手建立连接，四次握手终止连接</li></ul></li><li>可靠的 <ul><li>保证连接的可靠，数据校验完整性，数据的可控制（重传策略）</li></ul></li></ul><p>UDP（<strong>用户数据报协议</strong>）<br> 无需建立连接就可以发送封装的 IP 数据包的方法，音频和多媒体应用，UDP是最好的选择<br> 如果有一个消息丢失，在稍后的瞬间之后另一个新的消息就会替换它</p><ul><li>无连接 <ul><li>传输数据之前源端和终端不建立连接，不需要维护连接状态</li></ul></li><li>不可控（不可靠） <ul><li>无法保障数据完整性</li></ul></li></ul></div><h2 id="tcp-握手" tabindex="-1">TCP 握手 <a class="header-anchor" href="#tcp-握手" aria-hidden="true">#</a></h2><h3 id="建立连接" tabindex="-1">建立连接 <a class="header-anchor" href="#建立连接" aria-hidden="true">#</a></h3><p>TCP 作为传输层协议，使用三次握手协议建立连接，该方法可以防止产生错误的连接<br> TCP三次握手的过程如下：</p><ol><li>客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。</li><li>服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK（ACK=x+1）报文，进入SYN_RECV状态。</li><li>客户端检查ACK === x+1，随之发送ACK（ACK=y+1）报⽂给服务端，服务端检查ACK === y+1， 如果正确则建⽴连接，进入Established状态。</li></ol><p>三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">SYN </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 连接请求</span></span>
<span class="line"><span style="color:#F8F8F2;">ACK </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 应答信号 </span><span style="color:#F92672;">/</span><span style="color:#F8F8F2;"> 确认标志</span></span>
<span class="line"><span style="color:#F8F8F2;">SYN_SEND </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 发送完一个连接请求后等待一个匹配的连接请求</span></span>
<span class="line"><span style="color:#F8F8F2;">SYN_RECV </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 发送连接请求并且接收到匹配的连接请求以后等待连接请求确认</span></span>
<span class="line"><span style="color:#F8F8F2;">Established </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 表示一个建立的连接</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2;">client </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;">                  client发送 SYN（SEQ</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">x）请求建立连接                 </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> server</span></span>
<span class="line"><span style="color:#F8F8F2;">server </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 收到client请求应答, server回应 SYN （SEQ</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">y）</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;"> ACK（ACK</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">x</span><span style="color:#F92672;">+</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">）请求建立连接  </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> client</span></span>
<span class="line"><span style="color:#F8F8F2;">client </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 检测server的数据 ACK </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> x</span><span style="color:#F92672;">+</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, 正确则发送 ACK（ACK</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">y</span><span style="color:#F92672;">+</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">）, 服务器检测client的数据 ACK </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> y</span><span style="color:#F92672;">+</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, 正确则建立连接 </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> server</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>为什么不两次握手？<br> 客户端如果由于网络阻塞重发送了两次 SYN，服务端回应第一次的 SYN + ACK，服务端不知道客户端是否接收到 SYN + ACK，第二次 SYN 延迟送达 服务端依然会发送 SYN + ACK，因为服务端不知道客户端是否接受到 确认标志，这样会浪费服务端的资源</p><p>为什么不四次握手？<br> 浪费服务端资源，服务端的 SYN + ACK 可以一次性发送<br><img src="`+d+`" alt=""></p><h3 id="连接终止" tabindex="-1">连接终止 <a class="header-anchor" href="#连接终止" aria-hidden="true">#</a></h3><p>TCP 连接的终止一个连接要经过四次握手</p><ol><li>Client发送一个FIN并包含一个随机的seq=a，主动关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态</li><li>Server收到FIN后，发送一个ACK并包含一个seq=a+1给Client,Server进入CLOSE_WAIT状态。</li><li>Server发送一个FIN并包含一个随机的seq=b和一个ACK=a+1,用来关闭Server到Client的数据传输，Server进入LAST_ACK状态。</li><li>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK并包含一个seq=b+1给Server,Server收到ACK包后进入CLOSED状态，完成四次挥手</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">FIN </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 连接终止</span></span>
<span class="line"><span style="color:#F8F8F2;">seq </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 随机序列</span></span>
<span class="line"><span style="color:#F8F8F2;">ACK </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 应答信号 </span><span style="color:#F92672;">/</span><span style="color:#F8F8F2;"> 确认标志</span></span>
<span class="line"><span style="color:#F8F8F2;">FIN_WAIT_1 </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 等待远端TCP 的连接终止请求</span></span>
<span class="line"><span style="color:#F8F8F2;">CLOSE_WAIT </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 等待本地连接终止请求</span></span>
<span class="line"><span style="color:#F8F8F2;">LAST_ACK </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 等待先前发送给远端TCP 的连接终止请求的确认</span></span>
<span class="line"><span style="color:#F8F8F2;">TIME_WAIT </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认</span></span>
<span class="line"><span style="color:#F8F8F2;">CLOSED </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 关闭连接状态</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2;">client </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> client发送 FIN（seq</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">a） </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> server</span></span>
<span class="line"><span style="color:#F8F8F2;">server </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 收到client的 FIN，发送 ACK（seq</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">a</span><span style="color:#F92672;">+</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">） </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> client</span></span>
<span class="line"><span style="color:#F8F8F2;">server </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> server发送 FIN（seq</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">b）</span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;"> ACK（ACK</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">a</span><span style="color:#F92672;">+</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">） </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> client</span></span>
<span class="line"><span style="color:#F8F8F2;">client </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> 收到server的 FIN，client进入等待连接终止，并发送 ACK（seq</span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;">b</span><span style="color:#F92672;">+</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">），server收到 ACK 后进入关闭状态 </span><span style="color:#F92672;">-&gt;</span><span style="color:#F8F8F2;"> server</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><img src="`+c+'" alt=""></p><ol><li>DNS（ <strong>应⽤层</strong> -<strong>将域名和</strong> ip<strong>相互映射，计算机互相访问</strong> ）</li><li>DNS协议解析，通过域名查找 IP地址</li><li>DNS是⼀个分布式数据库，如果所访问的 DNS服务器不存在计算机请求的域名，则会重定向到另⼀台 DNS服 务器</li></ol><p><img src="'+g+'" alt=""></p><ol start="7"><li>HOST</li><li>例如：访问百度 <strong><a href="http://www.baidu.com" target="_blank" rel="noreferrer">www.baidu.com</a> --&gt; 119.75.217.109</strong></li><li>相当于是我们本地的⼀个DNS服务</li><li>输⼊域名时，计算机会先到<strong>host</strong>⽂件夹⾥⾯查找有没有这个域名。</li><li>如果存在，则直接访问这个该域名对应的IP，加快了域名解析；</li><li>如果没有，再去DNS服务器查找IP</li></ol><p>1 0.0.0.0 #屏蔽的⽹站<img src="'+F+'" alt=""></p><ol start="8"><li>TCP/IP协议</li><li>TCP协议（ <strong>传输层</strong> -<strong>传输控制协议</strong> -<strong>应⽤程序之间通讯</strong> ）</li><li><strong>从应⽤层处收到的数据（</strong> HTTP<strong>请求报⽂）进⾏分割，并在各个报⽂上打上标记序号及端⼝号后转发给⽹ 络层</strong></li><li>作⽤： <ol><li>将⼤块数据分割成报⽂段为单位的数据包，确保数据能到达⽬标</li></ol></li><li>字节流服务</li><li>将⼤块数据分割成报⽂段为单位的数据包进⾏管理</li><li>能够将数据准确可靠地传输给对⽅</li></ol><ol start="2"><li>IP协议（ <strong>⽹络层</strong> -<strong>⽹络协议</strong> -<strong>计算机之间的通信</strong> ）</li><li><strong>增加作为通信⽬的地的</strong> MAC<strong>地址后转发给链路层</strong></li><li>作⽤： <ol><li>把各种数据包传送给对⽅</li></ol></li><li>需要满⾜ IP<strong>地址</strong> 和 MAC<strong>地址</strong></li></ol><p>\\1. 通过解析 IP地址，得知 MAC地址，进⾏路由选择传输数据</p><p><img src="'+A+'" alt=""></p><ol start="2"><li>服务器</li><li>1台服务器可以有多台虚拟主机，每个主机可以设置⼀个域名</li></ol><p><img src="'+h+'" alt=""></p><ol start="2"><li><strong>代理</strong></li><li>转发功能的应⽤程序</li><li>接收代理客户端的请求，（可以修改后）并转发给服务器</li></ol><p>i. 也可以接收服务器返回的响应，（可以修改后）转发给客户端</p><ol><li><strong>⽹关</strong></li><li>转发其他服务器通信数据的服务器</li><li>接收从客户端（ client）发送来的请求时</li><li>它可以像⾃⼰拥有资源服务器⼀样对请求进⾏处理</li><li><strong>隧道</strong></li></ol><p>i. 在客户端和服务器之间进⾏中转，并保持双⽅通信连接的应⽤程序</p><ol start="11"><li>HTTP缺点</li><li>通信使⽤明⽂（不加密），内容可能被窃听</li><li>不验证通信⽅的身份，身份可能遭遇伪装</li><li>⽆法证明明⽂的完整性，明⽂可能会被篡改</li><li>HTTPS</li><li>通过 SSL协议 + 加密 + 认证 + 明⽂完整性保护</li><li>⽹站通信进⾏加密</li><li>Web安全漏洞</li><li>XSS（跨站脚本攻击）</li><li>通过虚假输⼊表单骗取⽤户个⼈信息</li><li>显示伪造的⽂章或图⽚</li><li><strong>通过表单输⼊，动态⽣成</strong> script<strong>等造成漏洞危险</strong></li></ol><p><img src="'+b+'" alt=""></p><ol start="2"><li>SQL注⼊攻击</li><li>⾮法查看或篡改数据库数据</li><li>规避认证</li><li>通过表单输⼊，查询或提交时，使⽤处理过的字符串请求接⼝</li><li>当服务器调⽤ SQL语句时，特殊的字符串就会注⼊到 SQL语句中，造成意想不到的结果</li></ol><p><strong>TCP：互联⽹协议(传输控制协议)，是TCP/IP中的⽹络层协议核⼼</strong></p><ol><li><p>传输层（<strong>报⽂段</strong>也可称为<strong>数据包</strong>）</p></li><li><p>TCP把数据流分割成适当⻓度的报⽂段</p></li><li><p>之后TCP把数据包传给IP层</p></li><li><p>由IP层来通过路由⽹络将包传送给接收端实体的TCP层</p></li><li><p>TCP层会将接收到所有的报⽂段进⾏组装，如果有部分报⽂段丢失则会让其重新发送，直⾄成功组装完整数 据，才会进⼊<strong>应⽤层</strong></p></li><li><p>TCP的作⽤控制传输数据的完整性</p></li><li><p>TCP三次握⼿和四次挥⼿全过程</p></li><li><p>SYN：同步标志。该标志仅在三次握⼿建⽴TCP连接时有效。</p></li><li><p>ACK：确认标志。同时提示远端系统已经成功接收所有数据。</p></li><li><p>PSH: 表示有DATA数据传输。</p></li><li><p>FIN: 结束标志。</p></li><li><p>RST: reset表示连接重置。</p></li><li><p>URG: urgent紧急指针字段值有效。</p></li><li><p>SEQ：随机序列号</p></li><li><p>四次挥⼿</p></li><li><p>Client发送⼀个FIN并包含⼀个随机的seq=a，主动关闭Client到Server的数据传送，Client进⼊FIN_WAIT_1状</p></li></ol><p>态</p><ol start="2"><li>Server收到FIN后，发送⼀个ACK并包含⼀个seq=a+1给Client,Server进⼊CLOSE_WAIT状态。</li><li>Server发送⼀个FIN并包含⼀个随机的seq=b和⼀个ACK=a+1,⽤来关闭Server到Client的数据传输，Server进 ⼊LAST_ACK状态。</li><li>Client收到FIN后，Client进⼊TIME_WAIT状态，接着发送⼀个ACK并包含⼀个seq=b+1给Server,Servr收到 ACK包后进⼊CLOSED状态，完成四次挥⼿</li></ol><p><strong>IP：互联⽹协议(⽹络之间互连协议)，是TCP/IP中的⽹络层协议核⼼</strong></p><ol><li>IP信息包传送 <ol><li>IP⽹络之间信息数据传送的协议</li></ol></li><li>IP地址 <ol><li>每台⽹络设备都是独⼀⽆⼆的IP地址</li><li>每个IP信息包都包含<strong>⽬的设备</strong>的IP地址</li><li>⽤于⽹络之间通信到对应的IP地址</li></ol></li><li>IP路由</li><li>IP地址与IP路由是IP信息包传送的基础</li><li>IP信息包必须通过IP路由的机制，在⼀个个路由器之间传递</li></ol><p><img src="'+y+'" alt=""></p><ol start="4"><li>传送⽅式 <ol><li>单点传送：单点传送是⼀对⼀的传递模式。</li><li>⼴播传送：⼴播传送是⼀对多的传递⽅式，必定会传送⾄某⼀个⽹络内的所有设备。</li><li>多点传送：多点传送是⼀对⼀的传递模式，传送给⼀群指定的设备。</li></ol></li><li>协议版本</li><li>IPV4：2019年IPV4地址分配完毕，地址个数4,294,967,296</li><li>IPV6</li><li>IP地址类型</li><li>公有地址，可以直接访问internet</li><li>私有地址</li></ol><p>i. 私有地址（Private address）属于⾮注册地址，专⻔为组织机构内部使⽤。</p><ol><li>A类 10.0.0.0--10.255.255.255</li><li>B类 172.16.0.0--172.31.255.255</li><li>C类 192.168.0.0--192.168.255.255</li></ol>',63),u=[C];function m(P,I,f,S,_,v){return l(),s("div",null,u)}const H=t(T,[["render",m]]);export{E as __pageData,H as default};
