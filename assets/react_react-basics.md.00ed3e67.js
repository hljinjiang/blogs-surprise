import{_ as o,c as s,b as l,d as i,e as r,a as t,o as n,r as a}from"./app.46bbe91d.js";const p="/docs-surprise/assets/Aspose.Words.bdb07b23-8480-466b-9fef-08b6ea7387cb.001.4b54eb3a.jpeg",c="/docs-surprise/assets/Aspose.Words.bdb07b23-8480-466b-9fef-08b6ea7387cb.002.f2ba4eec.jpeg",I=JSON.parse('{"title":"React Basics","description":"","frontmatter":{},"headers":[],"relativePath":"react/react-basics.md","lastUpdated":1673535819000}'),d={name:"react/react-basics.md"},u=l("h1",{id:"react-basics",tabindex:"-1"},[i("React Basics "),l("a",{class:"header-anchor",href:"#react-basics","aria-hidden":"true"},"#")],-1),_=t("<li>。函数组件（简单组件） <ol><li>⽆状态组件，不能驱动视图更新</li><li>没有 this指向</li></ol></li><li>类组件（复杂组件）</li><li>有状态组件，驱动视图更新</li><li>有 this指向</li><li>构造器 constructor中的 this指向该实例对象（构造器只调⽤⼀次，只在 new的时候调⽤）</li><li>类⽅法中的 this指向丢失的原因？？？</li><li>函数指向给 onclick， onclick点击时执⾏的函数在 dom上 <strong>直接调⽤</strong> ，⽽ <strong>不是在类实例对象中调⽤</strong></li><li>由于普通函数的 this指向为调⽤时所处的对象决定的，因⽽指向 window，⼜因为开启了 use strict， window变为了 undefined</li><li>三⼤属性</li><li>state：</li><li>是⼀个对象，称为状态</li><li>包含多个 key-value</li><li>更新 state中的属性值，便可以重新渲染对应 UI视图⻚⾯</li><li>state不可以直接更改属性</li><li>使⽤ this.setState({})只修改对应的属性以更改数据，驱动更改视图层</li>",15),m=l("li",null,"props是不可变的，⼦组件不可修改 props，由⽗组件传⼊⼦组件",-1),h=l("li",null,"import PropTypes from ‘prop-typesʼ，引⼊对属性 prop的限制",-1),f=l("li",null,"MyComponent.propTypes = { name: PropTypes.string.isRequired }；属性限制",-1),b=l("li",null,"MyComponent.defaultProps = { name: 'json' }：属性默认值",-1),g=l("li",null,"refs",-1),T=l("li",null,"属性定义到 render中任何标签或组件上，以访问绑定的 dom节点",-1),P=l("li",null,"⻚⾯内所有输⼊类 dom，现⽤现取，属于⾮受控组件",-1),R=l("li",null,"⻚⾯内所有输⼊类 dom，value值存储于 state⾥⾯，需要⽤的时候才拿出来，数据由 state状态管理，属 于受控组件",-1),S={ref:"input1"},x=l("li",null,"<input ref={e => (this.input2 = e)} />（更新数据时会触发两次事件，⼀次为 null⼀次为 dom节点；因 为每次渲染时会创建⼀个新的函数实例，所以 react清空旧的 ref并设置新的）",-1),y=l("li",null,"通过将回调函数定义成 class的绑定函数可以避免",-1),A={ref:"{this.input1}"},C={ref:"{this.myRef}"},U=t('<p>\\4. ⽣命周期</p><ol><li>挂载阶段</li><li>constructor(props)（构造函数最先调⽤）</li><li>static getDerivedStateFromProps(props, state)（罕⻅⽤例，即 state的值取决于 props） <ol><li>⼦组件的 state取决于⽗组件的 props；</li><li>return props or null</li></ol></li><li>componentWillmount（在组件挂载前）</li><li>render（渲染）</li><li>componentDidmount（在组件挂载后）</li><li>更新阶段</li><li>props传⼊的更新阶段</li><li>componentWillReceiveRrops(nextProps)（在组件接收参数前调⽤） <ol><li>在更新⼦组件，需要重新渲染组件时⽤到的⽐较多</li></ol></li><li>shouldComponentUpdate（需要组件更新） <ol><li>return Boolean（ true表示组件更新， false表示组件不更新）</li></ol></li><li>componentWillUpdate（组件更新前）</li><li>render（渲染）</li><li>getSnapshotBeforeUpdate（获取快照在更新前， return的值在下个钩⼦中接收） <ol><li>在 dom更新前调⽤，获取更新前的 dom信息</li><li>return null or snapshotValue</li></ol></li><li>componentDidUpdate(preProps, preState, snapshotValue)（组件更新后）</li><li>state渲染更新</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>render</li><li>componentDidUpdate</li><li>卸载阶段</li></ol><p>i. componentWillUnmount（组件卸载前）</p><ol start="5"><li>⽗⼦组件传值 <ol><li>⽗传⼦， <strong>通过</strong> prop<strong>属性传值</strong></li><li>⼦传⽗，通过 prop属性 <strong>将⽗组件⽅法传⼊⼦组件</strong> ，⼦组件 <strong>调⽤传⼊的属性⽅法</strong> ， <strong>触发⽗组件的⽅法</strong></li></ol></li><li>react-router-dom</li><li>路由组件和⼀般组件的区别</li><li>精确匹配和模糊匹配</li><li>params和 search(query)、 state</li><li>编程式路由导航 this.props.history.push(&#39;&#39;)</li><li>withRouter可以使⾮路由组件拥有路由组件特有的 API，进⾏编程式导航</li></ol><p><img src="'+p+'" alt=""></p><ol start="7"><li>redux</li></ol><p><img src="'+c+'" alt=""></p><ol><li>异步和同步 action</li><li>react-redux集中式管理</li><li>react-router</li><li>hooks</li><li>Fragment、 Context、 PureComponent、 getderivedStateFromError、 renderProps(插槽 )</li><li>组件间传值⽅式</li><li>⽗⼦： props</li><li>兄弟： pubsub、 redux</li><li>祖孙组件： pubsub、 redux、 context</li></ol>',8);function V(v,B,D,N,W,k){const e=a("A");return n(),s("div",null,[u,l("ol",null,[_,l("li",null,[i("props "),l("ol",null,[m,l("li",null,[i("对⼦组件传⼊ prop"),r(e,{name:"1",name1:"{1}"})]),h,f,b])]),g,T,P,R,l("li",null,[l("input",S,null,512)]),x,y,l("li",null,[l("input",A,null,512),i("（通过 input1函数的形参接收 dom节点）")]),l("li",null,[i("myRef = React.createRef()； "),l("input",C,null,512),i("； this.myRef.current则指向 dom")])]),U])}const E=o(d,[["render",V]]);export{I as __pageData,E as default};
