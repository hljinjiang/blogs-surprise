
# Node V8内存控制

## 基础

1. Node基于V8引擎使用内存，使用c++编译
   1. V8具有内存限制
   2. 原因是最初是对浏览器而设计的，不需要太大的内存
      1. 内存使用过多就会崩溃（没有足够的内存，内存溢出）
      2. 对象不再使用，而没有被销毁，内存一直没有被释放（内存泄漏）
2. V8垃圾回收机制算法
   1. 对不同对象的存货时间将内存的垃圾回收进不同的分代
   2. 对不同分代的内存使用更高效的回收算法

## 内存分配（V8堆的大小）
![o.png](./assets/v8_new.png)
1. 新生代的内存空间（生命周期短）
   1. 采用cheney算法，一种复制的方式实现垃圾回收算法
   2. 先是在From空间中进行分配，检测在From空间中的存活对象
   3. 存活对象将被复制到To空间，而非存活对象占用的空间将会被释放（闭包则不会被释放）
   4. 随后进行翻转，To -> From，From到To之前将会进行一次检测，在一定条件下将存活周期长的对象移入老生代
   5. 晋升的条件主要有两个：是否经历过回收依然未被释放，To空间的内存占用超过限制
    ![o.png](./assets/v8_new_one.png)
    ![o.png](./assets/v8_new_two.png)

2. 老生代的内存空间（生命周期长）
   1. 当一个对象经过多次复制依然存活时，它被认为是生周期较长的对象，将会移入到老生代中（称为晋升）
   2. 采用Mark-Sweep标记清除
      1. 标记阶段：遍历堆中的所有对象，并标记活着的对象
      2. 清除阶段：只清除没有被标记的对象
   3. 结合Mark-Compact标记整理
      1. 在标记对象死亡后，在整理过程中，将活着的对象往一端移动
      2. 移动完成后，直接清理掉边界外的内存
    ![o.png](./assets/v8_old_one.png)

## 增量标记（Incremental Marking）
1. 为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）
2. 增量标记：使垃圾回收最大停顿时间可以减少到原本的1/6左右
![o.png](./assets/v8_incremental_marking.png)
3. 延迟清理
4. 增量式清理
5. 并行标记、并行清理: 利用多核性能降低每次停顿时间

## 合理使用内存

让垃圾回收机制更高效的工作
foo()函数在每次调用时创建对应的作用域(scope)，在函数执行结束后，该作用域会销毁
同时在作用域中声明的局部变量分配在该作用域中，随作用域销毁而销毁
作用域释放后，局部变量local失效，引用对象将会在下次垃圾回收时释放

标识符查找
函数执行时会去查找该变量定义在哪里
最先查找当前作用域，当前作用域无法找到，会向上级的作用域查找，直到找到为止
作用域链
标识符的查找方向是向上的，所以变量只能向外访问，不能向内访问
变量的主动释放
定义在全局变量（不通过var声明或定义在global变量上），需要直到进程退出才能释放
这类引用对象常驻内存（常驻在老生代中）
如果需要释放常驻内存的对象，可以通过delete操作符删除引用关系
或者对变量重新赋值，让旧的对象脱离引用关系
在之后的老生代内存清除和整理过程中会被回收释放

闭包
外部作用域访问内部作用域中的变量的方法叫做闭包
这得益于高阶函数的特性：函数可以作用参数或返回值
内存溢出
操作函数操作使用内存过多，将会溢出堆内存
内存泄漏
缓存
造成原因：将内存当做缓存
解决办法①：缓存限制策略（限制存入对象数量）
解决方案②：
将缓存转移到外部，减少常驻内存的对象数量，让垃圾回收更高效
进程之间可以共享缓存
可以使用redis和memcached替代缓存操作
队列消费不及时
作用域未释放
大内存应用使用stream模块处理文件